
/****************************
 *  系统调用
 ****************************/

SWI
(1)什么是系统调用
系统调用是内核和应用程序间的接口，应用程序要访问硬件设备和其他操作系统资源，必须通过系统调用来完成。

在linux中，系统调用是用户空间访问内核的唯一手段，除异常和中断外，他们是内核唯一的合法入口。系统调用的数量很少，在i386上只有大概300个左右。


(2)c库和系统调用的关系
应用程序员通过C库中的应用程序接口(API)而不是直接通过系统调用来编程。C库中的函数可以不调用系统调用，也可以只是简单封装一个系统调用，还可以通过调用多个系统调用来实现一个功能。

应用程序-->C库-->内核的系统调用

从程序员的角度来看，系统调用无关紧要，他们只需要跟API打交道就可以了；
从内核的角度来看，内核只跟系统调用打交道，库函数及应用程序怎么使用系统调用不是内核所关心的。

unix的系统调用抽象出了用于完成某种特定目的的函数，而怎么使用这些函数则是用户的事情，内核并不关心。


(3)在内核中实现的系统调用函数
在用户空间中使用系统调用例子
#include <unistd.h>
getpid();

经过glibc库的封装，最终会调用内核中kernel/timer.c中的函数sys_getpid。见该函数。内核中所有的系统调用函数都用sys_开头。

asmlinkage
通知编译器，使用局部堆栈来传递参数

FASTCALL宏
通知编译器，使用寄存器来传递参数


(4)系统调用号
因为系统调用要从用户空间进入内核空间，所以不可能通过简单的函数调用完成，必须通过一些处理器支持的特殊机制(所谓的软中断)。

在x86上，这一特殊机制就是汇编指令int $0x80， 而在arm上，就是汇编指令SWI。
这条指令被封装到C库中的函数里，当程序执行到这一条指令后，cpu会进入一个特殊的异常模式(或软中断模式)，并将程序指针跳转到特点的位置(如arm为中断向量表的0x8处)。

内核中实现了很多的系统调用，这些系统调用的地址被按顺序放在一个系统调用表中，这个表是一个名为sys_call_table的数组，共有NR_syscalls个表项。通过这个表，就可以调用到内核定义的所以sys_函数

调用汇编指令int $0x80 或SWI 时，要同时传递一个系统调用号，这个系统调用号将作为索引，从sys_call_table中选择对应的系统调用。
int80将系统调用号保存在eax寄存器中，而SWI将其直接集成在指令中(如SWI 0x124)。


(5)系统调用的实现机制
内核中处理系统调用的函数定义在arch/i386/kernel/entry.s中的system_call，而arm系统在arch/arm/kernel/entry-common.s中的vector_swi。

x86系统的系统调用表定义在arch/i386/kernel/syscall_table.s(或直接定义在entry.s)中，而arm定义在arch/arm/kernel/calls.s中

系统调用号定义在include/asm/unistd.h中



(6)要实现系统调用需注意哪些方面
给linux添加一个系统调用不难，但怎么设计和实现一个系统调用是难题所在。linux不提倡采用多用途的系统调用(根据不同的参数提供不同的功能)。

系统调用必须仔细检查传入参数的有效性，尤其是用户提供的指针，必须确保：
*指针指向的内存区域属于用户空间，进程不能哄骗内核去读内核空间的数据
*指针指向的内存区域属于进程的地址空间，不能哄骗内核去读其他进程的数据
*进程不能绕过内存访问权限。

内核在执行系统调用的时候处于进程上下文，可以休眠，也可以被抢占，所以必须保证系统调用是可重入的。


(7)一个系统调用的例子(包括内核的修改和用户空间程序的实现)
实现一个系统调用sys_foo

a.添加系统调用号
修改include/asm/unistd.h，加入：
#define __NR_foo   289
并修改：
#define NR_syscalls 290

b.在系统调用表中添加
修改arch/i386/kernel/entry.s或syscall_table.s，加入：
  .long sys_foo
  
c.系统调用必须编译到核心的内核映像中，可以将系统调用的定义放置到和其功能联系最紧密的代码中，如kernel/sys.c，加入:
#include <asm/thread_info.h>

/* 
 * return the size of kernel stack
 */
asmlinkage long sys_foo(void)
{
  return  THREAD_SIZE;
}

d.在用户空间进行调用
通常，系统调用靠c库支持，glibc不可能支持我们自己的系统调用，此时，需要借助linux本身提供的一组宏来对系统调用直接进行访问。 
man 2 syscall


